{"ast":null,"code":"'use client';\n\nimport _slicedToArray from \"C:/Projects/Mod_App_Front/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport * as React from 'react';\n/**\n * Allows child elements to be transitioned in and out.\n *\n * Demos:\n *\n * - [Transitions](https://mui.com/base-ui/react-transitions/#hooks)\n *\n * API:\n *\n * - [useTransitionTrigger API](https://mui.com/base-ui/react-transitions/hooks-api/#use-transition-trigger)\n */\n\nexport function useTransitionTrigger(requestEnter) {\n  var _React$useState = React.useState(true),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      exitTransitionFinished = _React$useState2[0],\n      setExitTransitionFinished = _React$useState2[1];\n\n  var hasPendingExitTransition = React.useRef(false);\n  var registeredTransitions = React.useRef(0);\n\n  var _React$useState3 = React.useState(false),\n      _React$useState4 = _slicedToArray(_React$useState3, 2),\n      hasTransition = _React$useState4[0],\n      setHasTransition = _React$useState4[1];\n\n  var previousRequestEnter = React.useRef(requestEnter);\n  React.useEffect(function () {\n    if (!requestEnter && // checking registeredTransitions.current instead of hasTransition to avoid this effect re-firing whenever hasTransition changes\n    registeredTransitions.current > 0 && // prevents waiting for a pending transition right after mounting\n    previousRequestEnter.current !== requestEnter) {\n      hasPendingExitTransition.current = true;\n      setExitTransitionFinished(false);\n    }\n\n    previousRequestEnter.current = requestEnter;\n  }, [requestEnter]);\n  var handleExited = React.useCallback(function () {\n    hasPendingExitTransition.current = false;\n    setExitTransitionFinished(true);\n  }, []);\n  var registerTransition = React.useCallback(function () {\n    registeredTransitions.current += 1;\n    setHasTransition(true);\n    return function () {\n      registeredTransitions.current -= 1;\n\n      if (registeredTransitions.current === 0) {\n        setHasTransition(false);\n      }\n    };\n  }, []);\n  var hasExited;\n\n  if (!hasTransition) {\n    // If there are no transitions registered, the `exited` state is opposite of `requestEnter` immediately.\n    hasExited = !requestEnter;\n  } else if (requestEnter) {\n    hasExited = false;\n  } else {\n    hasExited = !hasPendingExitTransition.current && exitTransitionFinished;\n  }\n\n  var contextValue = React.useMemo(function () {\n    return {\n      requestedEnter: requestEnter,\n      onExited: handleExited,\n      registerTransition: registerTransition,\n      hasExited: hasExited\n    };\n  }, [handleExited, requestEnter, registerTransition, hasExited]);\n  return {\n    contextValue: contextValue,\n    hasExited: hasExited\n  };\n}","map":{"version":3,"sources":["C:/Projects/Mod_App_Front/node_modules/@mui/base/useTransition/useTransitionTrigger.js"],"names":["React","useTransitionTrigger","requestEnter","useState","exitTransitionFinished","setExitTransitionFinished","hasPendingExitTransition","useRef","registeredTransitions","hasTransition","setHasTransition","previousRequestEnter","useEffect","current","handleExited","useCallback","registerTransition","hasExited","contextValue","useMemo","requestedEnter","onExited"],"mappings":"AAAA;;;AAEA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,oBAAT,CAA8BC,YAA9B,EAA4C;AACjD,wBAA4DF,KAAK,CAACG,QAAN,CAAe,IAAf,CAA5D;AAAA;AAAA,MAAOC,sBAAP;AAAA,MAA+BC,yBAA/B;;AACA,MAAMC,wBAAwB,GAAGN,KAAK,CAACO,MAAN,CAAa,KAAb,CAAjC;AACA,MAAMC,qBAAqB,GAAGR,KAAK,CAACO,MAAN,CAAa,CAAb,CAA9B;;AACA,yBAA0CP,KAAK,CAACG,QAAN,CAAe,KAAf,CAA1C;AAAA;AAAA,MAAOM,aAAP;AAAA,MAAsBC,gBAAtB;;AACA,MAAMC,oBAAoB,GAAGX,KAAK,CAACO,MAAN,CAAaL,YAAb,CAA7B;AACAF,EAAAA,KAAK,CAACY,SAAN,CAAgB,YAAM;AACpB,QAAI,CAACV,YAAD,IACJ;AACAM,IAAAA,qBAAqB,CAACK,OAAtB,GAAgC,CAF5B,IAGJ;AACAF,IAAAA,oBAAoB,CAACE,OAArB,KAAiCX,YAJjC,EAI+C;AAC7CI,MAAAA,wBAAwB,CAACO,OAAzB,GAAmC,IAAnC;AACAR,MAAAA,yBAAyB,CAAC,KAAD,CAAzB;AACD;;AACDM,IAAAA,oBAAoB,CAACE,OAArB,GAA+BX,YAA/B;AACD,GAVD,EAUG,CAACA,YAAD,CAVH;AAWA,MAAMY,YAAY,GAAGd,KAAK,CAACe,WAAN,CAAkB,YAAM;AAC3CT,IAAAA,wBAAwB,CAACO,OAAzB,GAAmC,KAAnC;AACAR,IAAAA,yBAAyB,CAAC,IAAD,CAAzB;AACD,GAHoB,EAGlB,EAHkB,CAArB;AAIA,MAAMW,kBAAkB,GAAGhB,KAAK,CAACe,WAAN,CAAkB,YAAM;AACjDP,IAAAA,qBAAqB,CAACK,OAAtB,IAAiC,CAAjC;AACAH,IAAAA,gBAAgB,CAAC,IAAD,CAAhB;AACA,WAAO,YAAM;AACXF,MAAAA,qBAAqB,CAACK,OAAtB,IAAiC,CAAjC;;AACA,UAAIL,qBAAqB,CAACK,OAAtB,KAAkC,CAAtC,EAAyC;AACvCH,QAAAA,gBAAgB,CAAC,KAAD,CAAhB;AACD;AACF,KALD;AAMD,GAT0B,EASxB,EATwB,CAA3B;AAUA,MAAIO,SAAJ;;AACA,MAAI,CAACR,aAAL,EAAoB;AAClB;AACAQ,IAAAA,SAAS,GAAG,CAACf,YAAb;AACD,GAHD,MAGO,IAAIA,YAAJ,EAAkB;AACvBe,IAAAA,SAAS,GAAG,KAAZ;AACD,GAFM,MAEA;AACLA,IAAAA,SAAS,GAAG,CAACX,wBAAwB,CAACO,OAA1B,IAAqCT,sBAAjD;AACD;;AACD,MAAMc,YAAY,GAAGlB,KAAK,CAACmB,OAAN,CAAc;AAAA,WAAO;AACxCC,MAAAA,cAAc,EAAElB,YADwB;AAExCmB,MAAAA,QAAQ,EAAEP,YAF8B;AAGxCE,MAAAA,kBAAkB,EAAlBA,kBAHwC;AAIxCC,MAAAA,SAAS,EAATA;AAJwC,KAAP;AAAA,GAAd,EAKjB,CAACH,YAAD,EAAeZ,YAAf,EAA6Bc,kBAA7B,EAAiDC,SAAjD,CALiB,CAArB;AAMA,SAAO;AACLC,IAAAA,YAAY,EAAZA,YADK;AAELD,IAAAA,SAAS,EAATA;AAFK,GAAP;AAID","sourcesContent":["'use client';\n\nimport * as React from 'react';\n/**\n * Allows child elements to be transitioned in and out.\n *\n * Demos:\n *\n * - [Transitions](https://mui.com/base-ui/react-transitions/#hooks)\n *\n * API:\n *\n * - [useTransitionTrigger API](https://mui.com/base-ui/react-transitions/hooks-api/#use-transition-trigger)\n */\nexport function useTransitionTrigger(requestEnter) {\n  const [exitTransitionFinished, setExitTransitionFinished] = React.useState(true);\n  const hasPendingExitTransition = React.useRef(false);\n  const registeredTransitions = React.useRef(0);\n  const [hasTransition, setHasTransition] = React.useState(false);\n  const previousRequestEnter = React.useRef(requestEnter);\n  React.useEffect(() => {\n    if (!requestEnter &&\n    // checking registeredTransitions.current instead of hasTransition to avoid this effect re-firing whenever hasTransition changes\n    registeredTransitions.current > 0 &&\n    // prevents waiting for a pending transition right after mounting\n    previousRequestEnter.current !== requestEnter) {\n      hasPendingExitTransition.current = true;\n      setExitTransitionFinished(false);\n    }\n    previousRequestEnter.current = requestEnter;\n  }, [requestEnter]);\n  const handleExited = React.useCallback(() => {\n    hasPendingExitTransition.current = false;\n    setExitTransitionFinished(true);\n  }, []);\n  const registerTransition = React.useCallback(() => {\n    registeredTransitions.current += 1;\n    setHasTransition(true);\n    return () => {\n      registeredTransitions.current -= 1;\n      if (registeredTransitions.current === 0) {\n        setHasTransition(false);\n      }\n    };\n  }, []);\n  let hasExited;\n  if (!hasTransition) {\n    // If there are no transitions registered, the `exited` state is opposite of `requestEnter` immediately.\n    hasExited = !requestEnter;\n  } else if (requestEnter) {\n    hasExited = false;\n  } else {\n    hasExited = !hasPendingExitTransition.current && exitTransitionFinished;\n  }\n  const contextValue = React.useMemo(() => ({\n    requestedEnter: requestEnter,\n    onExited: handleExited,\n    registerTransition,\n    hasExited\n  }), [handleExited, requestEnter, registerTransition, hasExited]);\n  return {\n    contextValue,\n    hasExited\n  };\n}"]},"metadata":{},"sourceType":"module"}